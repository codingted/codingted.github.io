
JMM 

顺序一致性模型 通过synchronized关键字保证对外的可见性


1. 顺序一致性模型保证单线程内的操作会按程序的顺序执行,而 JMM 不保证单
线程内的操作会按程序的顺序执行(比如上面正确同步的多线程程序在临界区
内的重排序)。这一点前面已经讲过了,这里就不再赘述。
2. 顺序一致性模型保证所有线程只能看到一致的操作执行顺序,而 JMM 不保证
所有线程能看到一致的操作执行顺序。这一点前面也已经讲过,这里就不再赘
述。
3. JMM 不保证对 64 位的 long 型和 double 型变量的读/写操作具有原子性,而
顺序一致性模型保证对所有的内存读/写操作都具有原子性。



在每个 volatile 写操作的前面插入一个 StoreStore 屏障。
在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。
在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。
在每个 volatile 读操作的后面插入一个 LoadStore 屏障。


## JVM 内存溢出

### 堆内存

> 大对象初始化或这对象空间未被合理释放

解决方法:

* 增大堆内存的大小 (-Xmx)
### 过多的线程

> 线程需要占用系统内存，线程的栈空间是在堆外分配的

解决方法:

* 减少堆空间为线程预留更多的空间
* 减少线程占用的内存空间(-Xss:指定栈占用的内存大小)，为线程提供更多的内存空间
* 减少线程总数

### 栈内存

> 过深的递归调用

解决方法:

* 平衡栈空间和线程数之间的关系，规划内存空间

### 元数据区

> 太多的类型和cglib动态产生新的类

解决方法:

* 增加MaxPermSize
* 减少系统类的数量
* classLoader类加载顶起回收
