# CPU篇

## 理解"平均负载"

```shell
$uptime
 16:05:37 up 1 day, 29 min, 20 users,  load average: 1.44, 1.55, 1.57
 ```
>  16:05:37             // 当前系统时间
>  up 1 day, 29 min,    // 系统运行时间
>  20 users,            // 登录的用户数
>  load average: 1.44, 1.55, 1.57  // 1分钟,5分钟,15分钟的平均负载

<u>平均负载:是系统处于可运行状态和不可中断状态的平均进程数，也就是平均进程数</u> 

> 可运行状态:对应ps的R状态的进程;   
> 不可中断状态: 对应ps的D状态的进程;

```shell
# 查看cpu信息
$ lscpu
or
$ cat /proc/cupinfo
```

```shell
# 模拟cpu密集型
$stress --cpu 1 --timeout 60
# 模拟io密集型
$ stress -i 1 --timeout 60
# 大量进程的场景
$ stress -c 8 --timeout 60

# 查看平均负载
$ watch -d uptime
# 查看cpu使用率
$ mpstat -P ALL 5
# 查看进程情况
$ pidstat -u 5 1
```

## CPU 上下文切换

CPU 上下文切换的场景: 
* 进程
* 线程
* 中断处理程序调用


### 进程上下文切换

CPU的特权等级Ring 0 ~ Ring 3, 其中Ring 0 是内核态, 可以访问任何资源, 用户空间 Ring 3 用户态只能访问受限的资源,不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问特权资源.
在这个过程中就发生了CPU的上下文切换.

> 系统调用和进程上下文切换到区别:   
> 首先,进程是由内核来管理和调度的,进程的切换只能发生在内核态.所以进程的上下文不仅包含了虚拟内存,栈,全局变量等用户空间的资源,还包括了内核堆栈,寄存器等用户空间的资源,还包括了内核堆栈,寄存器等内核空间的状态.
> 因此,进程的上下文切换比系统调用多了一步:在保存当前进程的内核状态和CPU寄存器之前,需要先把该进程的虚拟内存,栈等保存下来;而加在了下一进程的内核太后,还需要刷新进程的虚拟内存和用户栈.
> 所以在进程频繁切换上下文导致CPU將大量的时间耗费在寄存器,内核栈一级虚拟内存等资源的保存和恢复上,进而缩短真正运行进程的时间.

> 进程被调度到CPU执行的时机?    
> 1, 某个进程的时间片耗尽,被系统挂起;
> 2, 进程系统资源不足(如内存不足),等到资源满足后才可以运行,进程被挂起;
> 3, 进程通过sleep主动挂起;
> 4, 高优先级进程运行时;
> 5, 发生硬件中断,CPU上的进程会被中断挂起,转而执行内核中的中断服务程序;

### 线程上下文切换

**线程是基本的调度单位,而进程则是资源拥有的基本单位**
即:
* 当进程只有一个线程时,进程等于线程;
* 当进程拥有多个线程时,线程共享虚拟内存和全局变量等资源,这些资源在上下文切换(线程)时,不需要修改;
* 线程有自己的私有数据,如栈和寄存器等,这些在上下文切换需要保存.

进程间的线程切换要比进程内的线程切换消耗更多的资源.

### 中断上下文切换

中断处理会打断进程的正常调度和执行,转而调用中断处理程序,响应设备事件.被打断的进程需要将其当前的状态保存下来,这样在中断结束后,进程仍然可以从原来的状态恢复运行.
跟进程的上下文不同,中断上下文切换并不涉及到进程的用户态.所以即使中断打断了一个用户态的进程也不需要保存和恢复虚拟内存,全局变量等用户态资源.
对同一个CPU来说,中断处理比进程拥有更高的优先级.所以中断上下文切换不会与进程上下文切换同时发生.同样道理,由于中断会打断正常运行的进程的调度和执行,所以大部分的中断处理程序都短小精悍,以便尽快执行完毕.

## 查看上下文切换

```shell
# 查看CPU的上下文切换和中断次数
$ vmstat 5
```

> cs (context swith) 每秒钟上下文切换的次数
> in (interrupt) 每秒中断的次数
> r 就绪队列的长度(正在运行的和等待CPU的进程数)
> b (Blocked) 处于不可中断睡眠转台的进程数


## CPU的使用率

user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。

nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。

> system（通常缩写为 sys），代表内核态 CPU 时间。
idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。
iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。
irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。
softirq（通常缩写为 si），代表处理软中断的 CPU 时间。
steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。
guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。
guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。


